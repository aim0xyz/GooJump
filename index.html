<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Time Bounce - CHAOS MODE</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #0f2027;
      overflow: hidden;
      font-family: Arial, sans-serif;
      color: white;
      text-align: center;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: rgba(0,0,0,0.3);
      border: 2px solid #444;
      transition: filter 0.3s ease;
    }
    canvas.chaos-flash { filter: hue-rotate(180deg) brightness(1.5); }
    
    #gameUI {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
    }
    /* Clean top UI (no boxes) */
    #score, #coinsDisplay, #heartsDisplay, #chaosTimer {
      position: absolute;
      font-size: 20px; font-weight: bold;
      padding: 10px;
      border-radius: 5px;
      display: none;
      pointer-events: none;
      background: none;
    }
    #score { top: 20px; left: 20px; }
    /* Coins above hearts (top-right) */
    #coinsDisplay {
      top: 8px;
      right: 20px;
      text-align: right;
      width: 120px;
    }
    #heartsDisplay {
      top: 38px;
      right: 20px;
      text-align: right;
      width: 120px;
    }
    #chaosTimer {
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
    }

    #chaosAlert {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      font-weight: bold;
      color: #ff3333;
      text-shadow: 2px 2px 4px black;
      display: none;
      z-index: 100;
      pointer-events: none;
    }

    /* Overlays */
    #loginRegisterScreen, #gameMenuScreen, #gameOverScreen, #shopScreen, #leaderboardScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      pointer-events: all;
      font-size: 22px;
      padding: 20px;
    }
    #gameMenuScreen, #gameOverScreen, #shopScreen, #leaderboardScreen { display: none; }

    h1 {
      font-size: 36px;
      margin: 20px 0;
      color: lime;
      text-shadow: 0 0 10px lime;
    }
    #gameOverScreen h1 {
      color: #FF6347;
      text-shadow: 0 0 10px #FF6347;
    }
    #shopScreen h1 {
      color: #00BFFF;
      text-shadow: 0 0 10px #00BFFF;
    }
    #leaderboardScreen h1 {
      color: #FFD700;
      text-shadow: 0 0 10px #FFD700;
    }
    p {
      font-size: 18px;
      margin: 10px 0;
    }

    /* Buttons */
    button {
      margin-top: 15px;
      padding: 15px 30px;
      font-size: 20px;
      border: none;
      border-radius: 10px;
      background: lime;
      color: black;
      font-weight: bold;
      cursor: pointer;
      pointer-events: all;
      transition: all 0.1s ease;
      max-width: 300px;
      width: 100%;
    }
    button:active {
      background: lightgreen;
      transform: scale(0.95);
    }
    #shopButton { background: #00BFFF; }
    #shopButton:active { background: #009ACD; }
    #reviveButton { background: #FFD700; color: black; }
    #reviveButton:active { background: #DAA520; }
    #reviveButton:disabled { background: #666; cursor: not-allowed; }
    #gameOverMenuButton, .back-button, #logoutButton { background: #808080; }
    #gameOverMenuButton:active, .back-button:active, #logoutButton:active { background: #696969; }

    /* Login/Register Specific */
    #loginRegisterScreen form {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      max-width: 400px;
      margin-bottom: 20px;
    }
    #loginRegisterScreen input {
      padding: 10px;
      font-size: 18px;
      border-radius: 5px;
      border: 1px solid #ccc;
      background: #333;
      color: white;
    }
    #loginRegisterScreen button {
      background: #4CAF50;
    }
    #loginRegisterScreen button:active {
      background: #45a049;
    }
    #loginRegisterScreen #googleSignInButton {
      background: #db4437; /* Google red */
      color: white;
    }
    #loginRegisterScreen #googleSignInButton:active {
      background: #c33d2e;
    }
    #authMessage {
      color: #ffcc00;
      font-size: 16px;
      margin-top: 10px;
    }
    #welcomeMessage {
      font-size: 24px;
      margin-bottom: 20px;
      color: #add8e6;
    }
    
    /* Shop item cleanup */
    .shop-item {
      background: #333;
      padding: 15px 25px;
      margin: 10px 0;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 80%;
      max-width: 380px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .shop-item span { font-size: 18px; margin-right: 15px; white-space: nowrap; }
    .shop-item button {
      margin: 0;
      padding: 8px 15px;
      font-size: 16px;
      background: #32CD32;
    }
    .shop-item button:active { background: #228B22; }

    /* Leaderboard Specific */
    #leaderboardList {
        list-style: none;
        padding: 0;
        width: 100%;
        max-width: 400px;
        margin-top: 20px;
    }
    #leaderboardList li {
        background: #333;
        margin-bottom: 8px;
        padding: 12px 20px;
        border-radius: 5px;
        display: flex;
        justify-content: space-between;
        font-size: 18px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    #leaderboardList li span:first-child {
        font-weight: bold;
        color: #ddd;
    }
    #leaderboardList li span:last-child {
        color: #FFD700;
        font-weight: bold;
    }

    /* Touch zones */
    #leftZone, #rightZone {
      position: absolute;
      top: 0;
      width: 50%;
      height: 100%;
      background: transparent;
      display: none;
      pointer-events: all;
    }
    #leftZone { left: 0; }
    #rightZone { right: 0; }
  </style>
  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
</head>
<body>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  
  <div id="gameUI">
    <div id="score">Height: 0m</div>
    <div id="coinsDisplay">Coins: 0</div>
    <div id="heartsDisplay">Hearts: ‚ù§Ô∏è 0</div>
    <div id="chaosTimer">Next Chaos: 10s</div>
    <div id="chaosAlert">GRAVITY FLIP!</div>
    <div id="leftZone"></div>
    <div id="rightZone"></div>

    <!-- Login/Register Screen -->
    <div id="loginRegisterScreen">
        <h1>TIME BOUNCE</h1>
        <p id="authMessage">Please login or register to play.</p>
        <form id="authForm">
            <input type="email" id="emailInput" placeholder="Email" required />
            <input type="password" id="passwordInput" placeholder="Password" required />
            <button type="submit" id="loginButton">Login</button>
            <button type="button" id="registerButton">Register</button>
            <button type="button" id="googleSignInButton">Sign in with Google</button>
        </form>
    </div>

    <!-- Main Game Menu Screen -->
    <div id="gameMenuScreen">
      <h1 id="welcomeMessage">Welcome!</h1>
      <p>üå™Ô∏è CHAOS MODE ENABLED üå™Ô∏è</p>
      <p>World shifts every 10 seconds!</p>
      <p>Climb as HIGH as possible!</p>
      <p>üí° Go through walls to wrap around!</p>
      <button id="startButton">START CLIMBING</button>
      <button id="shopButton">SHOP</button>
      <button id="leaderboardButton">LEADERBOARD</button>
      <button id="logoutButton">LOGOUT</button>
    </div>

    <div id="gameOverScreen">
      <h1>GAME OVER!</h1>
      <p id="finalHeightDisplay">Max Height: 0m</p>
      <p id="reviveMessage"></p>
      <button id="reviveButton">REVIVE (1 HEART)</button>
      <button id="gameOverMenuButton">MENU</button>
    </div>

    <div id="shopScreen">
      <h1>SHOP</h1>
      <p>Your Coins: <span id="shopCoinsDisplay">0</span></p>
      <div class="shop-item">
        <span>1 Heart (Revive)</span>
        <span>Cost: 50 Coins</span>
        <button id="buyHeartButton">BUY</button>
      </div>
      <button id="shopBackButton" class="back-button">BACK TO MENU</button>
    </div>

    <!-- Leaderboard Screen -->
    <div id="leaderboardScreen">
        <h1>LEADERBOARD</h1>
        <p>Top Climbers</p>
        <ul id="leaderboardList">
            <!-- Leaderboard items will be inserted here by JavaScript -->
        </ul>
        <button id="leaderboardBackButton" class="back-button">BACK TO MENU</button>
    </div>

  </div>

  <script>
    // Firebase Configuration - REPLACE WITH YOUR OWN!
    const firebaseConfig = {
    apiKey: "AIzaSyBNExyd0akuvuz0TNNb26MtuhlWQVFN0K8",
    authDomain: "goojump-2e9bc.firebaseapp.com",
    projectId: "goojump-2e9bc",
    storageBucket: "goojump-2e9bc.firebasestorage.app",
    messagingSenderId: "323169287474",
    appId: "1:323169287474:web:947d23f00d54c16652ab2b",
    measurementId: "G-LRV5CC7CT6"
  };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const googleProvider = new firebase.auth.GoogleAuthProvider();

    // UI Elements
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    
    // Game UI elements
    const scoreDisplay = document.getElementById("score");
    const coinsDisplay = document.getElementById("coinsDisplay"); // current round coins
    const heartsDisplay = document.getElementById("heartsDisplay");
    const chaosTimerDisplay = document.getElementById("chaosTimer");
    const chaosAlert = document.getElementById("chaosAlert");

    const leftZone = document.getElementById("leftZone");
    const rightZone = document.getElementById("rightZone");

    // Auth Screens & Elements
    const loginRegisterScreen = document.getElementById("loginRegisterScreen");
    const emailInput = document.getElementById("emailInput");
    const passwordInput = document.getElementById("passwordInput");
    const loginButton = document.getElementById("loginButton");
    const registerButton = document.getElementById("registerButton");
    const googleSignInButton = document.getElementById("googleSignInButton");
    const authMessage = document.getElementById("authMessage");
    const welcomeMessage = document.getElementById("welcomeMessage");

    // Game Menu Screen
    const gameMenuScreen = document.getElementById("gameMenuScreen");
    const startButton = document.getElementById("startButton");
    const shopButton = document.getElementById("shopButton");
    const leaderboardButton = document.getElementById("leaderboardButton");
    const logoutButton = document.getElementById("logoutButton");

    // Game Over Screen
    const gameOverScreen = document.getElementById("gameOverScreen");
    const finalHeightDisplay = document.getElementById("finalHeightDisplay");
    const reviveMessage = document.getElementById("reviveMessage");
    const reviveButton = document.getElementById("reviveButton");
    const gameOverMenuButton = document.getElementById("gameOverMenuButton");

    // Shop Screen
    const shopScreen = document.getElementById("shopScreen");
    const shopCoinsDisplay = document.getElementById("shopCoinsDisplay"); // total coins
    const buyHeartButton = document.getElementById("buyHeartButton");
    const shopBackButton = document.getElementById("shopBackButton");

    // Leaderboard Screen
    const leaderboardScreen = document.getElementById("leaderboardScreen");
    const leaderboardList = document.getElementById("leaderboardList");
    const leaderboardBackButton = document.getElementById("leaderboardBackButton");

    // Game State
    let gameRunning = false;
    let worldOffsetY = 0;
    let platforms = [];
    let gameTimeMs = 0;
    let lastChaosTime = 0;
    const chaosInterval = 10000;

    // Currency
    let totalCoins = 0;        // Available (shop) coins
    let currentRoundCoins = 0; // Coins collected this round (shown in-game)
    let hearts = 1; // Starting hearts, will be loaded from Firebase
    let maxHeight = 0; // Max height for current user, loaded from Firebase

    let maxRevivesPerGame = 1;
    let currentRevivesUsed = 0;
    let lastDeathState = null; // For revive

    // Coins in the world
    const coinSize = 16;
    const coinValue = 1;
    const coinChance = 0.2;
    let gameCoins = []; // { x, y, collected }

    // Goo splats
    const gooSplats = [];
    
    // Input
    let inputLeft = false;
    let inputRight = false;

    // CHAOS MODES
    let currentChaos = "normal";
    const chaosModes = [
      "normal",
      "gravity_flip",
      "reverse_controls", 
      "super_speed",
      "slippery",
      "tiny_platforms",
      "bouncy",
      "slow_motion"
    ];

    // Shop items
    const shopItems = {
      heart: { cost: 50, name: "Heart (1 Revive)" }
    };

    // Player
    const player = {
      x: 170, y: 440,
      width: 60, height: 60,
      dx: 0, dy: 0,

      baseSpeed: 0.9,
      baseMaxSpeed: 6,
      baseFriction: 0.86,
      baseGravity: 0.42,
      baseJumpPower: -10.5,
      
      speed: 0.9,
      maxSpeed: 6,
      friction: 0.86,
      gravity: 0.42,
      jumpPower: -10.5,

      bodyColor: "#9D4EDD",
      eyeLeft: "#FFD166",
      eyeRight: "#457B9D",

      squishT: 0
    };

    function getPlatformWidth() {
      return currentChaos === "tiny_platforms" ? 60 : 100;
    }

    function heightMeters() {
      return Math.max(0, Math.floor(worldOffsetY / 5));
    }

    function updateUI() {
      scoreDisplay.textContent = `${heightMeters()}m`;
      coinsDisplay.textContent = `üü° ${currentRoundCoins}`;
      heartsDisplay.textContent = `‚ù§Ô∏è ${hearts}`;
      shopCoinsDisplay.textContent = totalCoins;
    }

    function applyChaosMode(mode) {
      currentChaos = mode;

      // Reset to base
      player.speed = player.baseSpeed;
      player.maxSpeed = player.baseMaxSpeed;
      player.friction = player.baseFriction;
      player.gravity = player.baseGravity;
      player.jumpPower = player.baseJumpPower;

      switch (mode) {
        case "normal":
          showChaosAlert("NORMAL MODE");
          setCharacterColor("#9D4EDD");
          break;
        case "gravity_flip":
          showChaosAlert("GRAVITY FLIP!");
          player.gravity = -0.42;
          player.jumpPower = 10.5;
          setCharacterColor("#FF69B4");
          break;
        case "reverse_controls":
          showChaosAlert("REVERSE CONTROLS!");
          setCharacterColor("#FFA500");
          break;
        case "super_speed":
          showChaosAlert("SUPER SPEED!");
          player.speed = 2.1;
          player.maxSpeed = 12;
          setCharacterColor("#00FFFF");
          break;
        case "slippery":
          showChaosAlert("SLIPPERY MODE!");
          player.friction = 0.98;
          setCharacterColor("#ADD8E6");
          break;
        case "tiny_platforms":
          showChaosAlert("TINY PLATFORMS!");
          setCharacterColor("#FFD700");
          break;
        case "bouncy":
          showChaosAlert("BOUNCY MODE!");
          player.jumpPower = -15.5;
          setCharacterColor("#FF69B4");
          break;
        case "slow_motion":
          showChaosAlert("SLOW MOTION!");
          player.speed = 0.35;
          player.maxSpeed = 3.2;
          player.gravity = 0.16;
          player.jumpPower = -10.5;
          setCharacterColor("#9370DB");
          break;
      }

      canvas.classList.add('chaos-flash');
      setTimeout(() => canvas.classList.remove('chaos-flash'), 500);
    }

    function setCharacterColor(color) {
      player.bodyColor = color;
    }
    
    function showChaosAlert(text) {
      chaosAlert.textContent = text;
      chaosAlert.style.display = "block";
      setTimeout(() => { chaosAlert.style.display = "none"; }, 2000);
    }

    function createPlatforms() {
      platforms = [];
      gameCoins = [];
      const spacing = 120;
      // Start platform
      platforms.push({
        x: 150,
        y: canvas.height - 50,
        width: 100,
        height: 16,
        phase: Math.random() * Math.PI * 2
      });

      for (let i = 1; i < 8; i++) {
        const w = getPlatformWidth();
        const newPlatform = {
          x: Math.random() * (canvas.width - w),
          y: canvas.height - 50 - (i * spacing),
          width: w,
          height: 16,
          phase: Math.random() * Math.PI * 2
        };
        platforms.push(newPlatform);
        if (Math.random() < coinChance) {
          gameCoins.push({
            x: newPlatform.x + newPlatform.width / 2 - coinSize / 2,
            y: newPlatform.y - coinSize - 5,
            collected: false
          });
        }
      }
    }

    // --- Authentication & UI Navigation ---
    function hideAllScreens() {
      loginRegisterScreen.style.display = "none";
      gameMenuScreen.style.display = "none";
      gameOverScreen.style.display = "none";
      shopScreen.style.display = "none";
      leaderboardScreen.style.display = "none";

      scoreDisplay.style.display = "none";
      coinsDisplay.style.display = "none";
      heartsDisplay.style.display = "none";
      chaosTimerDisplay.style.display = "none";
      chaosAlert.style.display = "none";
      leftZone.style.display = "none";
      rightZone.style.display = "none";
    }

    function showLoginRegisterScreen(message = "Please login or register to play.") {
        hideAllScreens();
        loginRegisterScreen.style.display = "flex";
        authMessage.textContent = message;
        emailInput.value = '';
        passwordInput.value = '';
    }

    function showGameMenuScreen() {
        hideAllScreens();
        gameMenuScreen.style.display = "flex";
        updateUI(); // Update coins and hearts displayed on menu
    }

    function showShopScreen() {
      hideAllScreens();
      shopScreen.style.display = "flex";
      updateUI();
    }

    async function showLeaderboardScreen() {
        hideAllScreens();
        leaderboardScreen.style.display = "flex";
        leaderboardList.innerHTML = '<li>Loading leaderboard...</li>';
        await loadLeaderboard();
    }

    function showGameUI() {
      hideAllScreens();
      scoreDisplay.style.display = "block";
      coinsDisplay.style.display = "block";
      heartsDisplay.style.display = "block";
      chaosTimerDisplay.style.display = "block";
      leftZone.style.display = "block";
      rightZone.style.display = "block";
    }

    function getCameraThreshold() {
      return canvas.height * (currentChaos === "gravity_flip" ? 0.6 : 0.4);
    }

    // --- Firebase Auth Functions ---
    async function registerUser() {
        const email = emailInput.value;
        const password = passwordInput.value;
        try {
            const userCredential = await auth.createUserWithEmailAndPassword(email, password);
            const user = userCredential.user;
            // Initialize user data in Firestore
            await db.collection('users').doc(user.uid).set({
                email: user.email,
                totalCoins: 0,
                hearts: 1,
                maxHeight: 0
            });
            authMessage.textContent = "Registration successful! Logging in...";
        } catch (error) {
            authMessage.textContent = `Registration failed: ${error.message}`;
            console.error("Registration error:", error);
        }
    }

    async function loginUser() {
        const email = emailInput.value;
        const password = passwordInput.value;
        try {
            await auth.signInWithEmailAndPassword(email, password);
            authMessage.textContent = "Login successful!";
        } catch (error) {
            authMessage.textContent = `Login failed: ${error.message}`;
            console.error("Login error:", error);
        }
    }

    async function signInWithGoogle() {
        try {
            const result = await auth.signInWithPopup(googleProvider);
            const user = result.user;
            // Check if user data exists, if not, create it
            const userDoc = await db.collection('users').doc(user.uid).get();
            if (!userDoc.exists) {
                await db.collection('users').doc(user.uid).set({
                    email: user.email,
                    totalCoins: 0,
                    hearts: 1,
                    maxHeight: 0
                });
            }
            authMessage.textContent = "Google Sign-In successful!";
        } catch (error) {
            authMessage.textContent = `Google Sign-In failed: ${error.message}`;
            console.error("Google Sign-In error:", error);
        }
    }

    async function signOutUser() {
        try {
            await auth.signOut();
            authMessage.textContent = "Logged out.";
            // Reset local game state variables
            totalCoins = 0;
            hearts = 1;
            maxHeight = 0;
            currentRoundCoins = 0;
            showLoginRegisterScreen("You have been logged out.");
        } catch (error) {
            console.error("Logout error:", error);
            alert("Error logging out: " + error.message);
        }
    }

    // --- Firebase Data Management ---
    let currentUserDataRef = null; // Reference to the current user's Firestore document

    auth.onAuthStateChanged(async (user) => {
        if (user) {
            // User is signed in.
            welcomeMessage.textContent = `Welcome, ${user.email.split('@')[0]}!`;
            currentUserDataRef = db.collection('users').doc(user.uid);
            await loadUserData(user.uid);
            showGameMenuScreen();
        } else {
            // User is signed out.
            currentUserDataRef = null;
            showLoginRegisterScreen();
        }
    });

    async function loadUserData(uid) {
        if (!uid) return;
        try {
            const doc = await db.collection('users').doc(uid).get();
            if (doc.exists) {
                const data = doc.data();
                totalCoins = data.totalCoins || 0;
                hearts = data.hearts || 1;
                maxHeight = data.maxHeight || 0;
                console.log("User data loaded:", data);
            } else {
                console.log("No user data found for UID:", uid);
                // Create basic data if it doesn't exist (e.g., for new users signing up directly with Google)
                await db.collection('users').doc(uid).set({
                    email: auth.currentUser.email,
                    totalCoins: 0,
                    hearts: 1,
                    maxHeight: 0
                });
                totalCoins = 0;
                hearts = 1;
                maxHeight = 0;
            }
            updateUI();
        } catch (error) {
            console.error("Error loading user data:", error);
            alert("Error loading your game data: " + error.message);
        }
    }

    async function saveUserData() {
        if (!currentUserDataRef) {
            console.warn("No user logged in to save data.");
            return;
        }
        try {
            await currentUserDataRef.update({
                totalCoins: totalCoins,
                hearts: hearts,
                maxHeight: Math.max(maxHeight, heightMeters()) // Update max height if current is greater
            });
            maxHeight = Math.max(maxHeight, heightMeters()); // Update local max height
            console.log("User data saved successfully.");
        } catch (error) {
            console.error("Error saving user data:", error);
            alert("Error saving your game data: " + error.message);
        }
    }

    async function loadLeaderboard() {
        leaderboardList.innerHTML = ''; // Clear previous list
        try {
            const querySnapshot = await db.collection('users')
                                          .orderBy('maxHeight', 'desc')
                                          .limit(10)
                                          .get();
            if (querySnapshot.empty) {
                leaderboardList.innerHTML = '<li>No scores yet. Be the first!</li>';
                return;
            }

            querySnapshot.forEach((doc, index) => {
                const data = doc.data();
                const username = data.email ? data.email.split('@')[0] : 'Unknown Player';
                const score = data.maxHeight || 0;
                const li = document.createElement('li');
                li.innerHTML = `<span>${index + 1}. ${username}</span><span>${score}m</span>`;
                leaderboardList.appendChild(li);
            });
        } catch (error) {
            console.error("Error loading leaderboard:", error);
            leaderboardList.innerHTML = `<li>Error loading leaderboard: ${error.message}</li>`;
        }
    }

    // --- Game Flow ---
    function startGame() {
      if (!auth.currentUser) {
          showLoginRegisterScreen("Please login to start a game.");
          return;
      }
      gameRunning = true;
      worldOffsetY = 0;
      gameTimeMs = 0;
      lastChaosTime = 0;
      currentRevivesUsed = 0;
      currentRoundCoins = 0;
      
      applyChaosMode("normal");

      player.x = (canvas.width - player.width) / 2;
      player.y = 440;
      player.dx = 0;
      player.dy = 0;
      player.squishT = 0;

      gooSplats.length = 0;
      gameCoins.length = 0;
      createPlatforms();

      showGameUI();
      updateUI();

      requestAnimationFrame(gameLoop);
    }

    function resumeGame() {
      gameRunning = true;
      showGameUI();
      updateUI();
      gameLoop.lastTS = 0; // ensure clean dt after pause
      requestAnimationFrame(gameLoop);
    }

    async function endGame() {
      gameRunning = false;

      // Save state for potential revive (same height, same world)
      lastDeathState = {
        player: {
          x: player.x, y: player.y, dx: player.dx, dy: player.dy,
          bodyColor: player.bodyColor, eyeLeft: player.eyeLeft, eyeRight: player.eyeRight
        },
        worldOffsetY: worldOffsetY,
        platforms: platforms.map(p => ({...p})),
        gameCoins: gameCoins.map(c => ({...c}))
      };

      hideAllScreens();
      gameOverScreen.style.display = "flex";
      finalHeightDisplay.textContent = `Max Height: ${heightMeters()}m`;

      // Decide revive availability
      if (currentRevivesUsed < maxRevivesPerGame && hearts > 0) {
        reviveButton.disabled = false;
        reviveMessage.textContent = "You can revive this round!";
      } else {
        reviveButton.disabled = true;
        if (currentRevivesUsed >= maxRevivesPerGame) {
          reviveMessage.textContent = "You've used your only revive for this round.";
        } else if (hearts <= 0) {
          reviveMessage.textContent = "Not enough hearts to revive. Visit the shop!";
        } else {
          reviveMessage.textContent = "No revives left for this round.";
        }
      }

      inputLeft = false;
      inputRight = false;
    }

    function reviveGame() {
      if (!lastDeathState || currentRevivesUsed >= maxRevivesPerGame || hearts <= 0) return;

      // Consume heart and mark revive used
      hearts--;
      currentRevivesUsed++;

      // Restore world (height, platforms, remaining coins)
      worldOffsetY = lastDeathState.worldOffsetY;
      platforms = lastDeathState.platforms.map(p => ({...p}));
      gameCoins = lastDeathState.gameCoins.map(c => ({...c})).filter(c => !c.collected);

      // Safe on-screen respawn at same height:
      // place the player at the camera threshold inside the viewport
      const safeY = getCameraThreshold();
      player.y = safeY;
      // Keep x (or center if you prefer):
      // player.x = (canvas.width - player.width) / 2;
      // Give a small bounce so they don't feel "stuck"
      player.dy = player.jumpPower * 0.6;
      // Keep current horizontal velocity mild
      player.dx = Math.max(-2, Math.min(2, lastDeathState.player.dx || 0));

      gooSplats.length = 0;
      lastDeathState = null;

      resumeGame();
    }

    function buyHeart() {
      const item = shopItems.heart;
      if (totalCoins >= item.cost) {
        totalCoins -= item.cost;
        hearts++;
        updateUI();
        saveUserData(); // Save changes to Firebase
        alert(`You bought 1 ${item.name}!`);
      } else {
        alert(`Not enough coins! You need ${item.cost - totalCoins} more.`);
      }
    }

    async function showGameMenuScreenAndTransferCoins() {
      // Only when leaving game to menu do we bank the run coins
      totalCoins += currentRoundCoins;
      currentRoundCoins = 0;
      await saveUserData(); // Save updated coins and potentially new high score
      updateUI();
      showGameMenuScreen();
    }

    // --- Event Listeners ---
    // Auth Buttons
    loginButton.addEventListener('click', loginUser);
    registerButton.addEventListener('click', registerUser);
    googleSignInButton.addEventListener('click', signInWithGoogle);
    logoutButton.addEventListener('click', signOutUser);

    // Game Menu Buttons
    startButton.addEventListener('click', startGame);
    startButton.addEventListener('touchstart', (e) => { e.preventDefault(); startGame(); });

    shopButton.addEventListener('click', showShopScreen);
    shopButton.addEventListener('touchstart', (e) => { e.preventDefault(); showShopScreen(); });

    leaderboardButton.addEventListener('click', showLeaderboardScreen);
    leaderboardButton.addEventListener('touchstart', (e) => { e.preventDefault(); showLeaderboardScreen(); });

    // Shop Buttons
    buyHeartButton.addEventListener('click', buyHeart);
    buyHeartButton.addEventListener('touchstart', (e) => { e.preventDefault(); buyHeart(); });

    shopBackButton.addEventListener('click', showGameMenuScreen);
    shopBackButton.addEventListener('touchstart', (e) => { e.preventDefault(); showGameMenuScreen(); });

    // Game Over Buttons
    reviveButton.addEventListener('click', reviveGame);
    reviveButton.addEventListener('touchstart', (e) => { e.preventDefault(); reviveGame(); });

    gameOverMenuButton.addEventListener('click', showGameMenuScreenAndTransferCoins);
    gameOverMenuButton.addEventListener('touchstart', (e) => { e.preventDefault(); showGameMenuScreenAndTransferCoins(); });

    // Leaderboard Buttons
    leaderboardBackButton.addEventListener('click', showGameMenuScreen);
    leaderboardBackButton.addEventListener('touchstart', (e) => { e.preventDefault(); showGameMenuScreen(); });

    // Game Input
    leftZone.addEventListener('touchstart', (e) => { e.preventDefault(); inputLeft = true; });
    leftZone.addEventListener('touchend',   (e) => { e.preventDefault(); inputLeft = false; });
    rightZone.addEventListener('touchstart',(e) => { e.preventDefault(); inputRight = true; });
    rightZone.addEventListener('touchend',  (e) => { e.preventDefault(); inputRight = false; });

    document.addEventListener('keydown', (e) => {
      if (!gameRunning) return;
      if (e.key === 'ArrowLeft' || e.key === 'a') inputLeft = true;
      if (e.key === 'ArrowRight' || e.key === 'd') inputRight = true;
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') inputLeft = false;
      if (e.key === 'ArrowRight' || e.key === 'd') inputRight = false;
    });

    // LOOP
    function gameLoop(ts) {
      if (!gameRunning) {
        gameLoop.lastTS = ts;
        return;
      }
      if (!gameLoop.lastTS) gameLoop.lastTS = ts;
      const dt = Math.min(32, ts - gameLoop.lastTS);
      gameLoop.lastTS = ts;

      gameTimeMs += dt;

      // Chaos timer
      if (gameTimeMs - lastChaosTime >= chaosInterval) {
        lastChaosTime = gameTimeMs;
        const randomChaos = chaosModes[Math.floor(Math.random() * chaosModes.length)];
        applyChaosMode(randomChaos);
      }
      const timeToNextChaos = Math.max(0, chaosInterval - (gameTimeMs - lastChaosTime));
      chaosTimerDisplay.textContent = `Chaos: ${Math.ceil(timeToNextChaos / 1000)}s`;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    function update(dt) {
      // Input with reverse support
      let leftInput = inputLeft;
      let rightInput = inputRight;
      if (currentChaos === "reverse_controls") {
        leftInput = inputRight;
        rightInput = inputLeft;
      }
      if (leftInput) player.dx -= player.speed;
      if (rightInput) player.dx += player.speed;

      player.dx *= player.friction;
      player.dx = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, player.dx));
      player.x += player.dx;

      // Wrap horizontally
      if (player.x + player.width < 0) player.x = canvas.width;
      if (player.x > canvas.width) player.x = -player.width;

      // Gravity
      player.dy += player.gravity;
      player.y += player.dy;

      // Platform collisions
      let landed = false;
      let landedPlatform = null;

      for (let i = 0; i < platforms.length; i++) {
        const p = platforms[i];

        if (currentChaos === "gravity_flip") {
          const collide =
            player.x + player.width > p.x &&
            player.x < p.x + p.width &&
            player.y < p.y + p.height &&
            player.y > p.y - 12 &&
            player.dy < 0;

          if (collide) {
            player.dy = player.jumpPower;
            player.y = p.y + p.height;
            landed = true;
            landedPlatform = p;
            break;
          }
        } else {
          const collide =
            player.x + player.width > p.x &&
            player.x < p.x + p.width &&
            player.y + player.height > p.y &&
            player.y + player.height < p.y + p.height + 12 &&
            player.dy > 0;

          if (collide) {
            player.dy = player.jumpPower;
            player.y = p.y - player.height;
            landed = true;
            landedPlatform = p;
            break;
          }
        }
      }

      if (landed && landedPlatform) {
        spawnGooSplat(landedPlatform, currentChaos === "gravity_flip" ? +1 : -1);
        player.squishT = 1.0;
      }

      if (player.squishT > 0) player.squishT = Math.max(0, player.squishT - dt / 200);

      // Camera follow & height
      const cameraThreshold = getCameraThreshold();
      const passedThreshold =
        (currentChaos !== "gravity_flip" && player.y < cameraThreshold) ||
        (currentChaos === "gravity_flip" && player.y > cameraThreshold);

      if (passedThreshold) {
        const scrollAmount = Math.abs(cameraThreshold - player.y);
        player.y = cameraThreshold;

        worldOffsetY += scrollAmount;
        updateUI();

        if (currentChaos === "gravity_flip") {
          platforms.forEach(p => p.y -= scrollAmount);
          gameCoins.forEach(c => c.y -= scrollAmount);
          platforms = platforms.filter(p => p.y > -60);
          gameCoins = gameCoins.filter(c => c.y > -60);
          while (platforms.length < 8) {
            const bottom = platforms.reduce((low, p) => (p.y > low.y ? p : low));
            const w = getPlatformWidth();
            const newPlatform = {
              x: Math.random() * (canvas.width - w),
              y: bottom.y + 120,
              width: w,
              height: 16,
              phase: Math.random() * Math.PI * 2
            };
            platforms.push(newPlatform);
            if (Math.random() < coinChance) {
              gameCoins.push({
                x: newPlatform.x + newPlatform.width / 2 - coinSize / 2,
                y: newPlatform.y + newPlatform.height + 5,
                collected: false
              });
            }
          }
        } else {
          platforms.forEach(p => p.y += scrollAmount);
          gameCoins.forEach(c => c.y += scrollAmount);
          platforms = platforms.filter(p => p.y < canvas.height + 60);
          gameCoins = gameCoins.filter(c => c.y < canvas.height + 60);
          while (platforms.length < 8) {
            const top = platforms.reduce((hi, p) => (p.y < hi.y ? p : hi));
            const w = getPlatformWidth();
            const newPlatform = {
              x: Math.random() * (canvas.width - w),
              y: top.y - 120,
              width: w,
              height: 16,
              phase: Math.random() * Math.PI * 2
            };
            platforms.push(newPlatform);
            if (Math.random() < coinChance) {
              gameCoins.push({
                x: newPlatform.x + newPlatform.width / 2 - coinSize / 2,
                y: newPlatform.y - coinSize - 5,
                collected: false
              });
            }
          }
        }
      }

      // Update goo splats
      for (let i = gooSplats.length - 1; i >= 0; i--) {
        const g = gooSplats[i];
        g.t += dt;
        if (g.t >= g.life) {
          gooSplats.splice(i, 1);
        }
      }

      // Coin collection (current round only)
      for (let i = gameCoins.length - 1; i >= 0; i--) {
        const coin = gameCoins[i];
        if (!coin.collected) {
          if (
            player.x < coin.x + coinSize &&
            player.x + player.width > coin.x &&
            player.y < coin.y + coinSize &&
            player.y + player.height > coin.y
          ) {
            coin.collected = true;
            currentRoundCoins += coinValue;
            updateUI();
            gameCoins.splice(i, 1);
          }
        }
      }

      // Death condition
      if ((currentChaos !== "gravity_flip" && player.y > canvas.height + 60) ||
          (currentChaos === "gravity_flip" && player.y < -60)) {
        endGame();
      }
    }

    function spawnGooSplat(platform, dir) {
      const px = Math.max(platform.x, Math.min(player.x + player.width / 2, platform.x + platform.width));
      const y = dir < 0 ? platform.y : platform.y + platform.height;
      const baseColor = player.bodyColor;
      const life = 360;
      const width = Math.max(24, Math.min(player.width, platform.width * 0.8));
      gooSplats.push({ x: px, y, dir, t: 0, life, color: baseColor, w: width, drops: makeDroplets(px, y, dir, baseColor) });
    }

    function makeDroplets(x, y, dir, color) {
      const count = 3 + Math.floor(Math.random() * 3);
      const arr = [];
      for (let i = 0; i < count; i++) {
        arr.push({
          x: x + (Math.random() - 0.5) * 30,
          y: y + dir * (4 + Math.random() * 6),
          dir,
          t: 0,
          life: 420 + Math.random() * 200,
          r0: 2 + Math.random() * 3,
          vx: (Math.random() - 0.5) * 0.3,
          vy: dir * (0.05 + Math.random() * 0.15),
          color
        });
      }
      return arr;
    }

    // DRAWING
    function draw() {
      const t = gameTimeMs;
      const h = heightMeters();
      const chaosIntensity = h / 1000;

      drawEvolvingBackground(t, chaosIntensity);

      platforms.forEach(p => drawPlatform(p, t, chaosIntensity));
      gameCoins.forEach(c => drawCoin(c));
      drawGooSplats(t);
      drawCharacter(player.x, player.y, player.width, player.height, t);
    }

    function drawEvolvingBackground(t, intensity) {
      const ease = (x) => x < 0 ? 0 : x / (1 + x);
      const k = ease(intensity);

      const topHueShift = Math.min(60, k * 60);
      const bottomHueShift = Math.min(120, k * 120);

      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, hslShift("#2c5364", topHueShift, 0.0, 0.0));
      grad.addColorStop(0.5, hslShift("#203a43", topHueShift * 0.6, 0.05, 0.0));
      grad.addColorStop(1, hslShift("#0f2027", bottomHueShift, -0.05, -0.05));
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const blobCount = Math.floor(5 + Math.min(20, k * 12));
      const speed = 0.02 + Math.min(0.12, k * 0.08);
      const blur = Math.min(10, k * 10);
      const alpha = 0.08 + Math.min(0.2, k * 0.15);

      ctx.save();
      ctx.globalAlpha = alpha;
      if (ctx.filter !== undefined) ctx.filter = `blur(${blur.toFixed(1)}px)`;

      for (let i = 0; i < blobCount; i++) {
        const phase = i * 917;
        const x = (t * speed + phase) % (canvas.width + 120) - 60;
        const y = (t * speed * 0.6 + phase * 0.3) % (canvas.height + 120) - 60;
        const rx = 30 + 25 * Math.sin((t * 0.002) + i);
        const ry = 20 + 18 * Math.cos((t * 0.0025) - i);

        ctx.fillStyle = i % 2 === 0 ? player.bodyColor : "#457B9D";
        ctx.beginPath();
        ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      if (ctx.filter !== undefined) ctx.filter = "none";
      ctx.restore();
    }

    function hslShift(hex, hueShift, satDelta, lightDelta) {
      const {h, s, l} = hexToHsl(hex);
      let nh = (h + hueShift) % 360;
      let ns = Math.max(0, Math.min(1, s + satDelta));
      let nl = Math.max(0, Math.min(1, l + lightDelta));
      return `hsl(${nh}, ${Math.round(ns*100)}%, ${Math.round(nl*100)}%)`;
    }
    function hexToHsl(hex) {
      const {r,g,b} = hexToRgb(hex);
      const rn = r/255, gn = g/255, bn = b/255;
      const max = Math.max(rn,gn,bn), min = Math.min(rn,gn,bn);
      let h, s, l = (max + min)/2;
      if (max === min) { h = 0; s = 0; }
      else {
        const d = max - min;
        s = l > .5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case rn: h = (gn - bn) / d + (gn < bn ? 6 : 0); break;
          case gn: h = (bn - rn) / d + 2; break;
          case bn: h = (rn - gn) / d + 4; break;
        }
        h *= 60;
      }
      return {h, s, l};
    }
    function hexToRgb(hex) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m ? { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) } : {r:0,g:0,b:0};
    }

    function drawPlatform(p, t, chaosIntensity) {
      const wobbleAmp = 2 + Math.min(5, chaosIntensity * 2.5);
      const frequency = 0.003 + chaosIntensity * 0.0015;
      const phase = p.phase + t * frequency;

      const x = p.x;
      const y = p.y;
      const w = p.width;
      const h = p.height;

      const topY = y + (Math.sin(phase) * wobbleAmp);
      const botY = y + h + (Math.sin(phase + 1.9) * wobbleAmp * 0.6);

      const fill = ctx.createLinearGradient(0, y, 0, y + h);
      fill.addColorStop(0, hslShift("#6EA8D6", chaosIntensity * 30, -0.05, 0.05));
      fill.addColorStop(1, hslShift("#457B9D", chaosIntensity * 10, 0.0, -0.02));
      ctx.fillStyle = fill;

      ctx.lineWidth = 2;
      ctx.strokeStyle = "#000";
      ctx.setLineDash([8, 6]);
      ctx.lineDashOffset = Math.sin(t * 0.005 + p.phase) * 6;

      ctx.beginPath();
      ctx.moveTo(x + 10, topY);
      ctx.quadraticCurveTo(x, topY, x, topY + h/2);
      ctx.quadraticCurveTo(x, botY, x + 10, botY);
      ctx.lineTo(x + w - 10, botY);
      ctx.quadraticCurveTo(x + w, botY, x + w, topY + h/2);
      ctx.quadraticCurveTo(x + w, topY, x + w - 10, topY);
      ctx.closePath();

      ctx.fill();
      ctx.stroke();

      ctx.setLineDash([]);
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x + 8, topY + 4);
      ctx.lineTo(x + w - 8, topY + 4 + Math.sin(phase + 0.6) * 1.5);
      ctx.stroke();
    }

    function drawGooSplats(t) {
      for (const g of gooSplats) {
        const prog = g.t / g.life;
        const easeOut = 1 - Math.pow(1 - prog, 2);
        const alpha = 0.6 * (1 - easeOut);
        const radius = 6 + easeOut * 18;
        const width = g.w * (0.6 + 0.4 * (1 - easeOut));

        ctx.save();
        ctx.globalAlpha = alpha;
        if (ctx.filter !== undefined) ctx.filter = "blur(4px)";
        ctx.fillStyle = g.color;

        ctx.beginPath();
        const y = g.y + g.dir * (2 + easeOut * 4);
        const x1 = g.x - width / 2;
        const x2 = g.x + width / 2;
        ctx.moveTo(x1, y);
        ctx.quadraticCurveTo(x1 - radius, y + g.dir * radius, x1, y + g.dir * radius * 2);
        ctx.lineTo(x2, y + g.dir * radius * 2);
        ctx.quadraticCurveTo(x2 + radius, y + g.dir * radius, x2, y);
        ctx.closePath();
        ctx.fill();

        const bumps = 3;
        for (let i = 0; i < bumps; i++) {
          const bx = x1 + (i + 0.5) * (width / bumps);
          const br = 3 + easeOut * 6;
          ctx.beginPath();
          ctx.ellipse(bx, y + g.dir * (2 + i), br, br * 0.7, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        if (g.drops) {
          for (const d of g.drops) {
            d.t += 16;
            const dp = Math.min(1, d.t / d.life);
            const dr = d.r0 + dp * 3;
            const dalpha = 0.5 * (1 - dp);
            d.x += d.vx * 16;
            d.y += d.vy * 16;

            ctx.globalAlpha = dalpha;
            ctx.fillStyle = d.color;
            ctx.beginPath();
            ctx.ellipse(d.x, d.y, dr, dr * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        if (ctx.filter !== undefined) ctx.filter = "none";
        ctx.restore();
      }
    }

    function drawCoin(coin) {
      if (coin.collected) return;
      ctx.beginPath();
      ctx.arc(coin.x + coinSize / 2, coin.y + coinSize / 2, coinSize / 2, 0, Math.PI * 2);
      ctx.fillStyle = "gold";
      ctx.fill();
      ctx.strokeStyle = "orange";
      ctx.lineWidth = 2;
      ctx.stroke();

      if (Math.random() < 0.1) {
        ctx.save();
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(coin.x + coinSize / 2 + (Math.random()-0.5)*4, coin.y + coinSize / 2 + (Math.random()-0.5)*4, 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    function drawCharacter(x, y, w, h, t) {
      const squish = player.squishT;
      const squashY = 1 + 0.25 * squish;
      const squashX = 1 - 0.12 * squish;

      const cx = x + w / 2;
      const cy = y + h / 2;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.scale(squashX, squashY);
      ctx.translate(-cx, -cy);

      ctx.fillStyle = player.bodyColor;
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;

      ctx.beginPath();
      const wob = 2 + Math.sin(t * 0.005) * 1.5;
      const r = Math.min(w, h) / 2 - 3;
      const bx = cx, by = cy;
      for (let i = 0; i <= 16; i++) {
        const ang = (i / 16) * Math.PI * 2;
        const nr = r + Math.sin(ang * 3 + t * 0.003) * 2 + wob;
        const px = bx + Math.cos(ang) * nr;
        const py = by + Math.sin(ang) * nr;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Eyes
      ctx.fillStyle = "#FFD166";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1.5;
      const eyeLX = x + w * 0.38, eyeLY = y + h * 0.42;
      ctx.beginPath(); ctx.arc(eyeLX, eyeLY, 5.5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      ctx.fillStyle = "#000";
      ctx.beginPath(); ctx.arc(eyeLX, eyeLY, 2, 0, Math.PI * 2); ctx.fill();

      ctx.fillStyle = "#457B9D";
      ctx.strokeStyle = "#000";
      const eyeRX = x + w * 0.62, eyeRY = y + h * 0.5;
      ctx.beginPath(); ctx.arc(eyeRX, eyeRY, 4.5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      ctx.fillStyle = "#000";
      ctx.beginPath(); ctx.arc(eyeRX, eyeRY, 1.8, 0, Math.PI * 2); ctx.fill();

      ctx.restore();
    }

    // Init
    createPlatforms();
    draw();
    // Initially show the login/register screen
    showLoginRegisterScreen();
  </script>
</body>
</html>